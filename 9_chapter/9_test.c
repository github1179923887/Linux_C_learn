#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

// 匿名管道：一种只能用于父子进程或具有“血缘关系”的进程间通信的通信方式
// 管道是一种单向通信的方法，一个进行向管道写入数据、另一个进程从管道读取数据
//!管道创建之后，就需要确认通信双方的角色，谁作为发送发、谁作为接收方(即关闭相应的文件描述符)
// 访问管道跟访问文件一样，使用read 读取管道中的数据，使用 write 向管道中写入数据
// 需要注意的是，这个文件并不存在于磁盘中，管道中的数据是存放在内存中，所以读写管道并不会访问磁盘设备
// 并且每一个管道会产生两个文件描述符，一个用于读管道、一个用于写管道。

// int pipe(int pipefd[2])
//!数组中的第一个文件描述符用于读管道，第二个文件描述符用于写管道
// 配合fork函数使用，首先调用 pipe 函数创建匿名管道，然后调用 fork 函数创建子进程
// 所以子进程就会继承 pipe 函数所得到的的两个文件描述符，从而父子进程之间实现这个文件共享、也就实现了进程间通信

// 特点:
// 管道内部有同步、互斥机制
// 管道的生命周期随着进程的终止而终止，因为管道本质上是通过文件的方式进行访问
//!管道提供的是字节流服务，向管道写入数据或从管道中读取数据的字节大小是任意的只要不超过管道的容量,管道的大小通常是4K。并且管道中的数据是没有什么格式的
// 管道是单向传输的方式，如果要实现双向传输，我们可以创建两个管道
// 匿名管道只能是在父子进程间或者是具有血缘关系的进程之间进行通信

int main()
{
    int fds[2] = {0};
    if (pipe(fds) == -1)
    {
        perror("pipe error");
        exit(0);
    }

    switch (fork())
    {
    case -1:
        perror("fork error");
        exit(0);
    case 0:
        char rdbuf[64] = {0};
        printf("I am child, pid=%d\n", getpid());
        close(fds[1]);  // 实现读功能，关闭写fd

        while (1)
        {
            read(fds[0], rdbuf, sizeof(rdbuf));
            printf("%s\n", rdbuf);
            memset(rdbuf, 0x0, sizeof(rdbuf));
        }
        _exit(0);
    default:
        close(fds[0]);  // 实现写功能，关闭读fd
        printf("I am parent, pid=%d\n", getpid());

        while (1)
        {
            write(fds[1], "Hello World", 11);
            sleep(1);
        }
        exit(0);
    }
}

// 其他通信方式
//!命名管道
// 命名管道是有名字的，所以在进行进程间通信之前，需要创建这个管道文件,命名管道文件存在文件系统中，但不占用磁盘内存
// 管道文件有自己的名字，只要对这个管道文件进行读写操作，就可以向管道中写入数据或从管道中读取数据。
// 所以，命名管道可以作为同一台主机上的任意进程之间进行通信。
//!信号
// 信号可以作为进程间的通信手段，譬如用于通知某个进程发生了某事
//!内存映射
// 内存映射就是将文件映射到进程的地址空间,然后直接通过读写地址的方式去访问这个文件的内容。适用于多个进程之间的文件共享。
//!消息队列
//!共享内存
// 所谓共享内存就是指多个进程之间共享同一块内存区域
// 这块内存区域会映射到各个进程的地址空间，这些进程都可以访问这块内存区域，实现进程间通信
// 需要程序中去处理同步互斥的问题，他也是所有的进程间通信方法中最快的一种、效率最高
//!套接字(socket)
// 即网络通信